// Generated by gopygen; DO NOT EDIT
package example

import (
	"fmt"

	"github.com/qur/gopy/lib"
	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var GoObjectDef = py.Class{
	Name:    "GoObject",
	Pointer: (*GoObject)(nil),
}

// Registers this type with a python module
func RegisterGoObject(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = GoObjectDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("GoObject", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func (obj GoObject) Alloc() (*GoObject, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := GoObjectDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*GoObject)
	// Copy fields

	alloc.X = obj.X

	alloc.Y = obj.Y

	alloc.Z = obj.Z

	alloc.unexported = obj.unexported

	alloc.Map = obj.Map

	alloc.Slice = obj.Slice

	return alloc, nil
}

func (obj *GoObject) PyGet_X() (py.Object, error) {
	return gopygen.TypeConvOut(obj.X, "int")
}

func (obj *GoObject) PySet_X(arg py.Object) error {
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}
	obj.X = val.(int)
	return nil
}

func (obj *GoObject) PyGet_Y() (py.Object, error) {
	return gopygen.TypeConvOut(obj.Y, "int")
}

func (obj *GoObject) PySet_Y(arg py.Object) error {
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}
	obj.Y = val.(int)
	return nil
}

func (obj *GoObject) PyGet_Z() (py.Object, error) {
	return gopygen.TypeConvOut(obj.Z, "int")
}

func (obj *GoObject) PySet_Z(arg py.Object) error {
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}
	obj.Z = val.(int)
	return nil
}

func (obj *GoObject) PyGet_unexported() (py.Object, error) {
	return gopygen.TypeConvOut(obj.unexported, "int")
}

func (obj *GoObject) PySet_unexported(arg py.Object) error {
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}
	obj.unexported = val.(int)
	return nil
}

func (obj *GoObject) PyGet_Map() (py.Object, error) {
	return gopygen.TypeConvOut(obj.Map, "map[int]interface{}")
}

func (obj *GoObject) PySet_Map(arg py.Object) error {
	val, err := gopygen.TypeConvIn(arg, "map[int]interface{}")
	if err != nil {
		return err
	}
	obj.Map = val.(map[int]interface{})
	return nil
}

func (obj *GoObject) PyGet_Slice() (py.Object, error) {
	return gopygen.TypeConvOut(obj.Slice, "[]string")
}

func (obj *GoObject) PySet_Slice(arg py.Object) error {
	val, err := gopygen.TypeConvIn(arg, "[]string")
	if err != nil {
		return err
	}
	obj.Slice = val.([]string)
	return nil
}

func (o *GoObject) Py_FooBar_1(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_FooBar_1: parameter length mismatch")
	}

	in_0, err := gopygen.TypeConvIn(args[0], "int")
	if err != nil {
		return nil, err
	}

	res0 := o.FooBar_1(in_0.(int))

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}

	return out_0, nil

}

func (o *GoObject) Py_FooBar_2(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_FooBar_2: parameter length mismatch")
	}

	in_0, err := gopygen.TypeConvIn(args[0], "int")
	if err != nil {
		return nil, err
	}

	res0 := o.FooBar_2(in_0.(int))

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}

	return out_0, nil

}

func (o *GoObject) Py_FooBar_3(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 2 {
		return nil, fmt.Errorf("Py_FooBar_3: parameter length mismatch")
	}

	in_0, err := gopygen.TypeConvIn(args[0], "string")
	if err != nil {
		return nil, err
	}

	in_1, err := gopygen.TypeConvIn(args[1], "string")
	if err != nil {
		return nil, err
	}

	res0, res1 := o.FooBar_3(in_0.(string), in_1.(string))

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}

	out_1, err := gopygen.TypeConvOut(res1, "int")
	if err != nil {
		return nil, err
	}

	return py.PackTuple(out_0, out_1)

}

func (o *GoObject) Py_FooBar_4(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 2 {
		return nil, fmt.Errorf("Py_FooBar_4: parameter length mismatch")
	}

	in_0, err := gopygen.TypeConvIn(args[0], "string")
	if err != nil {
		return nil, err
	}

	in_1, err := gopygen.TypeConvIn(args[1], "string")
	if err != nil {
		return nil, err
	}

	res0, res1 := o.FooBar_4(in_0.(string), in_1.(string))

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}

	out_1, err := gopygen.TypeConvOut(res1, "int")
	if err != nil {
		return nil, err
	}

	return py.PackTuple(out_0, out_1)

}

func (o *GoObject) Py_FooBar_5(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_FooBar_5: parameter length mismatch")
	}

	in_0, err := gopygen.TypeConvIn(args[0], "int")
	if err != nil {
		return nil, err
	}

	o.FooBar_5(in_0.(int))

	py.None.Incref()
	return py.None, nil

}

func (o *GoObject) Py_FooBar_6(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_FooBar_6: parameter length mismatch")
	}

	res0 := o.FooBar_6()

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}

	return out_0, nil

}

func (o GoObject) Py_BarFoo(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_BarFoo: parameter length mismatch")
	}

	in_0, err := gopygen.TypeConvIn(args[0], "int")
	if err != nil {
		return nil, err
	}

	res0 := o.BarFoo(in_0.(int))

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}

	return out_0, nil

}
