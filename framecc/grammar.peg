{

package main

import (
	"github.com/sinusoids/gem/framecc/ast"
)

var currentFile *ast.File
var structStack []*ast.Struct

func toIfaceSlice(v interface{}) []interface{} {
	if v == nil {
		return nil
	}
	return v.([]interface{})
}

func lookupLocalField(name string) *ast.Field {
	currentStruct := structStack[len(structStack)-1]

	for _, f := range currentStruct.Fields {
		if f.Name == name {
			return f
		}
	}

	return nil
}

func parseFrameDefinition(inputFile string) (*ast.File, error) {
	currentFile = &ast.File{
		Types: make(map[string]ast.Type),
		Frames: make(map[string]*ast.Frame),
	}
	structStack = make([]*ast.Struct, 0)

	_, err := ParseFile(os.Args[1])
    if err != nil {
        return nil, err
    }

    return currentFile, nil
}

}

Start <- _ decls:Decl+ _ EOF {
	return currentFile, nil
}

Decl <- _ Frame _
     /  _ Struct _

Frame <- "frame" __ identifier:Ident '(' number:Number framesz:(',' _ FrameSize)? ')' _ object:TypeRef {
	if framesz == nil {
		framesz = ast.SzFixed
	} else {
		framesz = framesz.([]interface{})[2]
	}

	decl := &ast.Frame{
		Name: identifier.(string),
		Number: number.(int),
		Size: framesz.(ast.FrameSize),
		Object: object.(ast.Type),
	}

	currentFile.Frames[decl.Name] = decl
	return decl, nil
}

StructStart <- "struct" {
	decl := &ast.Struct{}
	structStack = append(structStack, decl)
	return decl, nil
}

Struct <- StructStart __ identifier:Ident _ StructBlock _ {
	decl := structStack[len(structStack)-1]
	decl.Name = identifier.(string)

	structStack = structStack[:len(structStack)-1]

	currentFile.Types[decl.Name] = decl
	return decl, nil
}

StructBlock <- '{' _ fields:Field+ _ '}' {
	fieldsSl := make([]*ast.Field, 0)
	fieldsIfSl := toIfaceSlice(fields)
	for _, fieldIfSl := range fieldsIfSl {
		fieldsSl = append(fieldsSl, fieldIfSl.(*ast.Field))
	}

	return fieldsSl, nil
}

Field <- _ identifier:Ident __ typ:Type EOL {
	decl := structStack[len(structStack)-1]

	field := &ast.Field{
		Name: identifier.(string),
		Type: typ.(ast.Type),
	}

	decl.Fields = append(decl.Fields, field)
	return field, nil
}

Type <- StringType / IntegerTypeNoFlags / IntegerTypeAndFlags / TypeRef

StringType <- "string" '[' size:Number ']' {
	return &ast.StringType{
		Length: size.(int),
	}, nil
} / "string" '[' fieldref:Ident ']' {
	field := lookupLocalField(fieldref.(string))
	if field == nil {
		return nil, fmt.Errorf("%v: %v", ast.ErrNoSuchField, fieldref)
	}

	switch field.Type.(type) {
	case *ast.IntegerType:
	default:
		return nil, fmt.Errorf("%v: %v", ast.ErrFieldNotInteger, fieldref)
	}

	return &ast.VariableStringType{
		Field: field,
	}, nil
}

IntegerTypeNoFlags <- baseType:IntegerType !(_ '(') {
	return baseType, nil
}

IntegerTypeAndFlags <- baseType:IntegerType '(' flags:(IntegerFlag (',' _)?)+ ')' {
	iType := baseType.(*ast.IntegerType)
	hasFlag := func(flags interface{}, flag string) bool {
		for _, f_ := range toIfaceSlice(flags) {
			f := toIfaceSlice(f_)
			if string(f[0].([]byte)) == flag {
				return true
			}
		}
		return false
	}

	modMap := map[string]ast.IntegerFlag {
		"negate": ast.IntNegate,
		"inv128": ast.IntInv128,
		"ofs128": ast.IntOfs128,
		"endian(little)": ast.IntLittleEndian,
		"endian(pdp)": ast.IntPDPEndian,
		"endian(rpdp)": ast.IntRPDPEndian,
	}

	for k, v := range modMap {
		if hasFlag(flags, k) {
			iType.Modifiers = iType.Modifiers | v
		}
	}

    return iType, nil
}

IntegerType <- unsigned:'u'? "int" bitsize:Number {
	signed := true
	if unsigned != nil {
		signed = false
	}

    return &ast.IntegerType{
		Signed: signed,
		Bitsize: bitsize.(int),
	}, nil
}

IntegerFlag <- "negate" / "inv128" / "ofs128" / "endian(little)" / "endian(pdp)" / "endian(rpdp)" {
    return string(c.text), nil
}

TypeRef <- name:Ident {
	if typ, ok := currentFile.Types[name.(string)]; !ok {
		return "", fmt.Errorf("%v: %v", ast.ErrNoSuchType, name.(string))
	} else {
		return typ, nil
	}
}

Ident <- [a-zA-Z0-9_]+ {
    return string(c.text), nil
}

Number <- [0-9]+ {
    return strconv.Atoi(string(c.text))
}

Value <- [a-zA-Z0-9]+ {
    return string(c.text), nil
} / Ident

FrameSize <- "var8" {
    return ast.SzVar8, nil
} / "var16" {
    return ast.SzVar16, nil
}

SourceChar <- .
Comment <- MultiLineComment / SingleLineComment
MultiLineComment <- "/*" ( !"*/" SourceChar )* "*/"
SingleLineComment <- "//" ( !EOL SourceChar )*

_  <- ( Whitespace / EOL / Comment )*
__ <- ( Whitespace / EOL / Comment )+

Whitespace <- [ \t\r]
EOL <- '\n'
EOF <- !.
