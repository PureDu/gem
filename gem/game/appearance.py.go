// Generated by gopygen; DO NOT EDIT
package game

import (
	"fmt"

	"github.com/qur/gopy/lib"
	"github.com/sinusoids/gem/gem/game/interface/player"
	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var AppearanceDef = py.Class{
	Name:    "Appearance",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Appearance)(nil),
}

// Registers this type with a python module
func RegisterAppearance(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = AppearanceDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Appearance", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewAppearance() (*Appearance, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := AppearanceDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Appearance)
	err = alloc.Init()
	return alloc, err
}

func (obj *Appearance) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return fmt.Errorf("(Appearance) PyInit: parameter length mismatch")
	}

	err = obj.Init()

	return err
}

func (obj *Appearance) PyGet_gender() (py.Object, error) {
	return gopygen.TypeConvOut(obj.gender, "int")
}

func (obj *Appearance) PySet_gender(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.gender
	obj.gender = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_headIcon() (py.Object, error) {
	return gopygen.TypeConvOut(obj.headIcon, "int")
}

func (obj *Appearance) PySet_headIcon(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.headIcon
	obj.headIcon = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_torsoModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.torsoModel, "int")
}

func (obj *Appearance) PySet_torsoModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.torsoModel
	obj.torsoModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_armsModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.armsModel, "int")
}

func (obj *Appearance) PySet_armsModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.armsModel
	obj.armsModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_legsModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.legsModel, "int")
}

func (obj *Appearance) PySet_legsModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.legsModel
	obj.legsModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_headModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.headModel, "int")
}

func (obj *Appearance) PySet_headModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.headModel
	obj.headModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_handsModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.handsModel, "int")
}

func (obj *Appearance) PySet_handsModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.handsModel
	obj.handsModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_feetModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.feetModel, "int")
}

func (obj *Appearance) PySet_feetModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.feetModel
	obj.feetModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_beardModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.beardModel, "int")
}

func (obj *Appearance) PySet_beardModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.beardModel
	obj.beardModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_hairColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.hairColor, "int")
}

func (obj *Appearance) PySet_hairColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.hairColor
	obj.hairColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_torsoColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.torsoColor, "int")
}

func (obj *Appearance) PySet_torsoColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.torsoColor
	obj.torsoColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_legsColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.legsColor, "int")
}

func (obj *Appearance) PySet_legsColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.legsColor
	obj.legsColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_feetColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.feetColor, "int")
}

func (obj *Appearance) PySet_feetColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.feetColor
	obj.feetColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_skinColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.skinColor, "int")
}

func (obj *Appearance) PySet_skinColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.skinColor
	obj.skinColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

var AnimationsDef = py.Class{
	Name:    "Animations",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Animations)(nil),
}

// Registers this type with a python module
func RegisterAnimations(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = AnimationsDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Animations", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewAnimations() (*Animations, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := AnimationsDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Animations)
	err = alloc.Init()
	return alloc, err
}

func (obj *Animations) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return fmt.Errorf("(Animations) PyInit: parameter length mismatch")
	}

	err = obj.Init()

	return err
}

func (obj *Animations) PyGet_idle() (py.Object, error) {
	return gopygen.TypeConvOut(obj.idle, "int")
}

func (obj *Animations) PySet_idle(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.idle
	obj.idle = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_spotRotate() (py.Object, error) {
	return gopygen.TypeConvOut(obj.spotRotate, "int")
}

func (obj *Animations) PySet_spotRotate(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.spotRotate
	obj.spotRotate = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_walk() (py.Object, error) {
	return gopygen.TypeConvOut(obj.walk, "int")
}

func (obj *Animations) PySet_walk(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.walk
	obj.walk = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_rotate180() (py.Object, error) {
	return gopygen.TypeConvOut(obj.rotate180, "int")
}

func (obj *Animations) PySet_rotate180(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.rotate180
	obj.rotate180 = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_rotateCCW() (py.Object, error) {
	return gopygen.TypeConvOut(obj.rotateCCW, "int")
}

func (obj *Animations) PySet_rotateCCW(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.rotateCCW
	obj.rotateCCW = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_rotateCW() (py.Object, error) {
	return gopygen.TypeConvOut(obj.rotateCW, "int")
}

func (obj *Animations) PySet_rotateCW(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.rotateCW
	obj.rotateCW = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_run() (py.Object, error) {
	return gopygen.TypeConvOut(obj.run, "int")
}

func (obj *Animations) PySet_run(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.run
	obj.run = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (a *Appearance) Py_Gender(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Gender: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := a.Gender()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (a *Appearance) Py_HeadIcon(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_HeadIcon: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := a.HeadIcon()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (a *Appearance) Py_Model(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_Model: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "player.BodyPart")
	if err != nil {
		return nil, err
	}

	// Make the function call

	res0 := a.Model(in_0.(player.BodyPart))

	// Remove local references

	args[0].Decref()

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (a *Appearance) Py_Color(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_Color: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "player.BodyPart")
	if err != nil {
		return nil, err
	}

	// Make the function call

	res0 := a.Color(in_0.(player.BodyPart))

	// Remove local references

	args[0].Decref()

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (a *Animations) Py_Animation(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_Animation: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "player.Anim")
	if err != nil {
		return nil, err
	}

	// Make the function call

	res0 := a.Animation(in_0.(player.Anim))

	// Remove local references

	args[0].Decref()

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}
