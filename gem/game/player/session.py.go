// Generated by gopygen; DO NOT EDIT
package player

import (
	"fmt"

	"github.com/gtank/isaac"
	"github.com/qur/gopy/lib"

	"github.com/sinusoids/gem/gem/game/interface/entity"
	"github.com/sinusoids/gem/gem/game/position"
	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var SessionDef = py.Class{
	Name:    "Session",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Session)(nil),
}

// Registers this type with a python module
func RegisterSession(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = SessionDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Session", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewSession() (*Session, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := SessionDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Session)
	err = alloc.Init()
	return alloc, err
}

func (obj *Session) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return fmt.Errorf("(Session) PyInit: parameter length mismatch")
	}

	err = obj.Init()

	return err
}

func (obj *Session) PyGet_randIn() (py.Object, error) {
	return gopygen.TypeConvOut(obj.randIn, "isaac.ISAAC")
}

func (obj *Session) PySet_randIn(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "isaac.ISAAC")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.randIn
	obj.randIn = val.(isaac.ISAAC)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_randOut() (py.Object, error) {
	return gopygen.TypeConvOut(obj.randOut, "isaac.ISAAC")
}

func (obj *Session) PySet_randOut(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "isaac.ISAAC")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.randOut
	obj.randOut = val.(isaac.ISAAC)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_serverRandKey() (py.Object, error) {
	return gopygen.TypeConvOut(obj.serverRandKey, "[]uint32")
}

func (obj *Session) PySet_serverRandKey(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "[]uint32")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.serverRandKey
	obj.serverRandKey = val.([]uint32)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_secureBlockSize() (py.Object, error) {
	return gopygen.TypeConvOut(obj.secureBlockSize, "int")
}

func (obj *Session) PySet_secureBlockSize(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.secureBlockSize
	obj.secureBlockSize = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_region() (py.Object, error) {
	return gopygen.TypeConvOut(obj.region, "*position.Region")
}

func (obj *Session) PySet_region(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "*position.Region")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.region
	obj.region = val.(*position.Region)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_flags() (py.Object, error) {
	return gopygen.TypeConvOut(obj.flags, "entity.Flags")
}

func (obj *Session) PySet_flags(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "entity.Flags")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.flags
	obj.flags = val.(entity.Flags)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_currentWalkDir() (py.Object, error) {
	return gopygen.TypeConvOut(obj.currentWalkDir, "int")
}

func (obj *Session) PySet_currentWalkDir(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.currentWalkDir
	obj.currentWalkDir = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Session) PyGet_lastWalkDir() (py.Object, error) {
	return gopygen.TypeConvOut(obj.lastWalkDir, "int")
}

func (obj *Session) PySet_lastWalkDir(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.lastWalkDir
	obj.lastWalkDir = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (s *Session) Py_Flags(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Flags: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.Flags()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "entity.Flags")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Session) Py_SetFlags(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_SetFlags: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "entity.Flags")
	if err != nil {
		return nil, err
	}

	// Make the function call

	s.SetFlags(in_0.(entity.Flags))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}

func (s *Session) Py_ClearFlags(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_ClearFlags: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	s.ClearFlags()

	// Remove local references

	py.None.Incref()
	return py.None, nil

}

func (s *Session) Py_Region(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Region: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.Region()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "*position.Region")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Session) Py_SetRegion(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_SetRegion: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "*position.Region")
	if err != nil {
		return nil, err
	}

	// Make the function call

	s.SetRegion(in_0.(*position.Region))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}

func (s *Session) Py_WalkDirection(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_WalkDirection: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0, res1 := s.WalkDirection()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	out_1, err := gopygen.TypeConvOut(res1, "int")
	if err != nil {
		return nil, err
	}
	out_1.Incref()

	return py.PackTuple(out_0, out_1)

}

func (s *Session) Py_ServerISAACSeed(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_ServerISAACSeed: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.ServerISAACSeed()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "[]uint32")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Session) Py_ISAACIn(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_ISAACIn: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.ISAACIn()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "isaac.ISAAC")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Session) Py_ISAACOut(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_ISAACOut: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.ISAACOut()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "isaac.ISAAC")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Session) Py_InitISAAC(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 2 {
		return nil, fmt.Errorf("Py_InitISAAC: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "[]uint32")
	if err != nil {
		return nil, err
	}

	args[1].Incref()
	in_1, err := gopygen.TypeConvIn(args[1], "[]uint32")
	if err != nil {
		return nil, err
	}

	// Make the function call

	s.InitISAAC(in_0.([]uint32), in_1.([]uint32))

	// Remove local references

	args[0].Decref()

	args[1].Decref()

	py.None.Incref()
	return py.None, nil

}

func (s *Session) Py_SecureBlockSize(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_SecureBlockSize: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.SecureBlockSize()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Session) Py_SetSecureBlockSize(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_SetSecureBlockSize: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "int")
	if err != nil {
		return nil, err
	}

	// Make the function call

	s.SetSecureBlockSize(in_0.(int))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}
