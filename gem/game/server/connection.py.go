// Generated by gopygen; DO NOT EDIT
package server

import (
	"fmt"
	"github.com/sinusoids/gem/gem/log"
	"net"

	"github.com/qur/gopy/lib"
	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var ConnectionDef = py.Class{
	Name:    "Connection",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Connection)(nil),
}

// Registers this type with a python module
func RegisterConnection(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = ConnectionDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Connection", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewConnection(arg_0 net.Conn, arg_1 *log.Module) (*Connection, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := ConnectionDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Connection)
	err = alloc.Init(arg_0, arg_1)
	return alloc, err
}

func (obj *Connection) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 2 {
		return fmt.Errorf("(Connection) PyInit: parameter length mismatch")
	}

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "net.Conn")
	if err != nil {
		return err
	}

	args[1].Incref()
	in_1, err := gopygen.TypeConvIn(args[1], "*log.Module")
	if err != nil {
		return err
	}

	err = obj.Init(in_0.(net.Conn), in_1.(*log.Module))

	args[0].Decref()

	args[1].Decref()

	return err
}

func (c *Connection) Py_Log(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Log: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := c.Log()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "*log.Module")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (conn *Connection) Py_WaitForDisconnect(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_WaitForDisconnect: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	conn.WaitForDisconnect()

	// Remove local references

	py.None.Incref()
	return py.None, nil

}

func (conn *Connection) Py_IsDisconnecting(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_IsDisconnecting: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := conn.IsDisconnecting()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "bool")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (conn *Connection) Py_Disconnect(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Disconnect: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	conn.Disconnect()

	// Remove local references

	py.None.Incref()
	return py.None, nil

}

func (conn *Connection) Py_Index(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Index: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := conn.Index()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (conn *Connection) Py_SetIndex(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_SetIndex: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "int")
	if err != nil {
		return nil, err
	}

	// Make the function call

	conn.SetIndex(in_0.(int))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}

func (conn *Connection) Py_flushWriteBuffer(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_flushWriteBuffer: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := conn.flushWriteBuffer()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "error")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (conn *Connection) Py_fillReadBuffer(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_fillReadBuffer: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := conn.fillReadBuffer()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "error")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}
