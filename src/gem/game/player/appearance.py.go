// Generated by gopygen; DO NOT EDIT
package player

import (
	"fmt"

	"github.com/qur/gopy/lib"
	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var AppearanceDef = py.Class{
	Name:    "Appearance",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Appearance)(nil),
}

// Registers this type with a python module
func RegisterAppearance(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = AppearanceDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Appearance", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewAppearance() (*Appearance, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := AppearanceDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Appearance)
	err = alloc.Init()
	return alloc, err
}

func (obj *Appearance) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return fmt.Errorf("(Appearance) PyInit: parameter length mismatch")
	}

	err = obj.Init()

	return err
}

func (obj *Appearance) PyGet_Gender() (py.Object, error) {
	return gopygen.TypeConvOut(obj.Gender, "int")
}

func (obj *Appearance) PySet_Gender(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.Gender
	obj.Gender = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_HeadIcon() (py.Object, error) {
	return gopygen.TypeConvOut(obj.HeadIcon, "int")
}

func (obj *Appearance) PySet_HeadIcon(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.HeadIcon
	obj.HeadIcon = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_TorsoModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.TorsoModel, "int")
}

func (obj *Appearance) PySet_TorsoModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.TorsoModel
	obj.TorsoModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_ArmsModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.ArmsModel, "int")
}

func (obj *Appearance) PySet_ArmsModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.ArmsModel
	obj.ArmsModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_LegsModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.LegsModel, "int")
}

func (obj *Appearance) PySet_LegsModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.LegsModel
	obj.LegsModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_HeadModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.HeadModel, "int")
}

func (obj *Appearance) PySet_HeadModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.HeadModel
	obj.HeadModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_HandsModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.HandsModel, "int")
}

func (obj *Appearance) PySet_HandsModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.HandsModel
	obj.HandsModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_FeetModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.FeetModel, "int")
}

func (obj *Appearance) PySet_FeetModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.FeetModel
	obj.FeetModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_BeardModel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.BeardModel, "int")
}

func (obj *Appearance) PySet_BeardModel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.BeardModel
	obj.BeardModel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_HairColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.HairColor, "int")
}

func (obj *Appearance) PySet_HairColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.HairColor
	obj.HairColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_TorsoColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.TorsoColor, "int")
}

func (obj *Appearance) PySet_TorsoColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.TorsoColor
	obj.TorsoColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_LegColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.LegColor, "int")
}

func (obj *Appearance) PySet_LegColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.LegColor
	obj.LegColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_FeetColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.FeetColor, "int")
}

func (obj *Appearance) PySet_FeetColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.FeetColor
	obj.FeetColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Appearance) PyGet_SkinColor() (py.Object, error) {
	return gopygen.TypeConvOut(obj.SkinColor, "int")
}

func (obj *Appearance) PySet_SkinColor(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.SkinColor
	obj.SkinColor = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

var AnimationsDef = py.Class{
	Name:    "Animations",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Animations)(nil),
}

// Registers this type with a python module
func RegisterAnimations(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = AnimationsDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Animations", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewAnimations() (*Animations, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := AnimationsDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Animations)
	err = alloc.Init()
	return alloc, err
}

func (obj *Animations) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return fmt.Errorf("(Animations) PyInit: parameter length mismatch")
	}

	err = obj.Init()

	return err
}

func (obj *Animations) PyGet_AnimIdle() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimIdle, "int")
}

func (obj *Animations) PySet_AnimIdle(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimIdle
	obj.AnimIdle = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_AnimSpotRotate() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimSpotRotate, "int")
}

func (obj *Animations) PySet_AnimSpotRotate(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimSpotRotate
	obj.AnimSpotRotate = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_AnimWalk() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimWalk, "int")
}

func (obj *Animations) PySet_AnimWalk(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimWalk
	obj.AnimWalk = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_AnimRotate180() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimRotate180, "int")
}

func (obj *Animations) PySet_AnimRotate180(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimRotate180
	obj.AnimRotate180 = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_AnimRotateCCW() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimRotateCCW, "int")
}

func (obj *Animations) PySet_AnimRotateCCW(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimRotateCCW
	obj.AnimRotateCCW = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_AnimRotateCW() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimRotateCW, "int")
}

func (obj *Animations) PySet_AnimRotateCW(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimRotateCW
	obj.AnimRotateCW = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Animations) PyGet_AnimRun() (py.Object, error) {
	return gopygen.TypeConvOut(obj.AnimRun, "int")
}

func (obj *Animations) PySet_AnimRun(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.AnimRun
	obj.AnimRun = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}
