// Generated by gopygen; DO NOT EDIT
package game

import (
	"fmt"
	"gem/game/player"
	"gem/game/position"

	"github.com/qur/gopy/lib"
	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var ProfileDef = py.Class{
	Name:    "Profile",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Profile)(nil),
}

// Registers this type with a python module
func RegisterProfile(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = ProfileDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Profile", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewProfile(arg_0 string, arg_1 string) (*Profile, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := ProfileDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Profile)
	err = alloc.Init(arg_0, arg_1)
	return alloc, err
}

func (obj *Profile) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 2 {
		return fmt.Errorf("(Profile) PyInit: parameter length mismatch")
	}

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "string")
	if err != nil {
		return err
	}

	args[1].Incref()
	in_1, err := gopygen.TypeConvIn(args[1], "string")
	if err != nil {
		return err
	}

	err = obj.Init(in_0.(string), in_1.(string))

	args[0].Decref()

	args[1].Decref()

	return err
}

func (obj *Profile) PyGet_username() (py.Object, error) {
	return gopygen.TypeConvOut(obj.username, "string")
}

func (obj *Profile) PySet_username(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "string")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.username
	obj.username = val.(string)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Profile) PyGet_password() (py.Object, error) {
	return gopygen.TypeConvOut(obj.password, "string")
}

func (obj *Profile) PySet_password(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "string")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.password
	obj.password = val.(string)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Profile) PyGet_rights() (py.Object, error) {
	return gopygen.TypeConvOut(obj.rights, "player.Rights")
}

func (obj *Profile) PySet_rights(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "player.Rights")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.rights
	obj.rights = val.(player.Rights)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Profile) PyGet_position() (py.Object, error) {
	return gopygen.TypeConvOut(obj.position, "*position.Absolute")
}

func (obj *Profile) PySet_position(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "*position.Absolute")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.position
	obj.position = val.(*position.Absolute)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Profile) PyGet_skills() (py.Object, error) {
	return gopygen.TypeConvOut(obj.skills, "*Skills")
}

func (obj *Profile) PySet_skills(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "*Skills")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.skills
	obj.skills = val.(*Skills)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Profile) PyGet_appearance() (py.Object, error) {
	return gopygen.TypeConvOut(obj.appearance, "*Appearance")
}

func (obj *Profile) PySet_appearance(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "*Appearance")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.appearance
	obj.appearance = val.(*Appearance)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Profile) PyGet_animations() (py.Object, error) {
	return gopygen.TypeConvOut(obj.animations, "*Animations")
}

func (obj *Profile) PySet_animations(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "*Animations")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.animations
	obj.animations = val.(*Animations)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

var SkillsDef = py.Class{
	Name:    "Skills",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Skills)(nil),
}

// Registers this type with a python module
func RegisterSkills(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = SkillsDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Skills", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewSkills() (*Skills, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := SkillsDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Skills)
	err = alloc.Init()
	return alloc, err
}

func (obj *Skills) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return fmt.Errorf("(Skills) PyInit: parameter length mismatch")
	}

	err = obj.Init()

	return err
}

func (obj *Skills) PyGet_combatLevel() (py.Object, error) {
	return gopygen.TypeConvOut(obj.combatLevel, "int")
}

func (obj *Skills) PySet_combatLevel(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "int")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.combatLevel
	obj.combatLevel = val.(int)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (p *Profile) Py_Username(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Username: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Username()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "string")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_Password(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Password: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Password()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "string")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_Rights(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Rights: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Rights()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "player.Rights")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_Position(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Position: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Position()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "*position.Absolute")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_SetPosition(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_SetPosition: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "*position.Absolute")
	if err != nil {
		return nil, err
	}

	// Make the function call

	p.SetPosition(in_0.(*position.Absolute))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}

func (p *Profile) Py_Skills(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Skills: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Skills()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "player.Skills")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_Appearance(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Appearance: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Appearance()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "player.Appearance")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_SetAppearance(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_SetAppearance: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "player.Appearance")
	if err != nil {
		return nil, err
	}

	// Make the function call

	p.SetAppearance(in_0.(player.Appearance))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}

func (p *Profile) Py_Animations(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_Animations: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.Animations()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "player.Animations")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (p *Profile) Py_String(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_String: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := p.String()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "string")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}

func (s *Skills) Py_CombatLevel(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 0 {
		return nil, fmt.Errorf("Py_CombatLevel: parameter length mismatch")
	}
	// Convert parameters

	// Make the function call

	res0 := s.CombatLevel()

	// Remove local references

	out_0, err := gopygen.TypeConvOut(res0, "int")
	if err != nil {
		return nil, err
	}
	out_0.Incref()

	return out_0, nil

}
