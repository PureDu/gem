// Generated by gopygen; DO NOT EDIT
package event

import (
	"fmt"

	"github.com/qur/gopy/lib"

	"github.com/tgascoigne/gopygen/gopygen"
)

// Sometimes we might generate code which doesn't use some of the above imports
// Use them here just in case
var _ = fmt.Sprintf("")
var _ = gopygen.Dummy

var EventDef = py.Class{
	Name:    "Event",
	Flags:   py.TPFLAGS_BASETYPE,
	Pointer: (*Event)(nil),
}

// Registers this type with a python module
func RegisterEvent(module *py.Module) error {
	var err error
	var class *py.Type
	if class, err = EventDef.Create(); err != nil {
		return err
	}

	if err = module.AddObject("Event", class); err != nil {
		return err
	}

	return nil
}

// Alloc allocates an object for use in python land.
// Copies the member fields from this object to the newly allocated object
// Usage: obj := GoObject{X:1, Y: 2}.Alloc()
func NewEvent(arg_0 string) (*Event, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	// Allocate
	alloc_, err := EventDef.Alloc(0)
	if err != nil {
		return nil, err
	}
	alloc := alloc_.(*Event)
	err = alloc.Init(arg_0)
	return alloc, err
}

func (obj *Event) PyInit(_args *py.Tuple, kwds *py.Dict) error {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return fmt.Errorf("(Event) PyInit: parameter length mismatch")
	}

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "string")
	if err != nil {
		return err
	}

	err = obj.Init(in_0.(string))

	args[0].Decref()

	return err
}

func (obj *Event) PyGet_key() (py.Object, error) {
	return gopygen.TypeConvOut(obj.key, "string")
}

func (obj *Event) PySet_key(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "string")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.key
	obj.key = val.(string)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (obj *Event) PyGet_observers() (py.Object, error) {
	return gopygen.TypeConvOut(obj.observers, "map[int]Observer")
}

func (obj *Event) PySet_observers(arg py.Object) error {
	arg.Incref()
	val, err := gopygen.TypeConvIn(arg, "map[int]Observer")
	if err != nil {
		return err
	}

	if _, ok := val.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		val.(py.Object).Incref()
	}
	arg.Decref()

	var tmp interface{}
	tmp = &obj.observers
	obj.observers = val.(map[int]Observer)

	if oldObj, ok := tmp.(py.Object); ok {
		// If we're not converting it from a python object, we should refcount it properly
		oldObj.Decref()
	}
	return nil
}

func (e *Event) Py_Register(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_Register: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "Observer")
	if err != nil {
		return nil, err
	}

	// Make the function call

	e.Register(in_0.(Observer))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}

func (e *Event) Py_Unregister(_args *py.Tuple, kwds *py.Dict) (py.Object, error) {
	lock := py.NewLock()
	defer lock.Unlock()

	var err error
	_ = err
	args := _args.Slice()
	if len(args) != 1 {
		return nil, fmt.Errorf("Py_Unregister: parameter length mismatch")
	}
	// Convert parameters

	args[0].Incref()
	in_0, err := gopygen.TypeConvIn(args[0], "Observer")
	if err != nil {
		return nil, err
	}

	// Make the function call

	e.Unregister(in_0.(Observer))

	// Remove local references

	args[0].Decref()

	py.None.Incref()
	return py.None, nil

}
